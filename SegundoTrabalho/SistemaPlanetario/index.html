<html>
<head>
  <title>Rendering primitives</title>
  <!--<link rel="shortcut icon" type="image/png" href="../common/images/favicon.png" />-->

  <!-- libraries -->
  <!--<link rel="stylesheet" href="../common/lib/normalize.css">-->
  <!--<script type="text/javascript" src="../common/lib/dat.gui.js"></script>-->

  <!-- modules -->
  <!--<script type="text/javascript" src="../common/js/utils.js"></script>-->

  <!-- vertex shader -->

  <link rel="stylesheet" href="./lib/normalize.css">
  <script type="text/javascript" src="./lib/dat.gui.js"></script>
  <script type="text/javascript" src="./js/utils.js"></script>
  <script type="text/javascript" src="./lib/gl-matrix.js"></script>
  <script type="text/javascript" src="./objects.js"></script>
  <script type="text/javascript" src="./simpleGLStack.js"></script>
  <script type="text/javascript" src="./geometry.js"></script>
  <script type="text/javascript" src="./webGLApp.js"></script>
  <script type="text/javascript" src="./webGLModel.js"></script>
  <script type="text/javascript" src="./shapes.js"></script>
  <script type="text/javascript" src="./shapesWebGL.js"></script>
  

<!--Vertex Shader-->
   
<script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    precision mediump float;
    precision mediump int;

    in vec3 aVertexPosition;
    in vec3 aVertexColor;
    in vec3 aVertexNormal;
    in vec2 aTextureCoordinate;
    

    smooth out vec4 vColor;
    smooth out vec3 vNormal;
    out vec2 vTextureCoordinate;
    uniform float uVertexPointSize;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uNormalMatrix;
    uniform mat4 uProjectionMatrix;
    uniform int uTextureActive;
    uniform vec3 uLightPos;
    uniform vec3 uEyePos;

    void main(void) {
      mat4 normalMatrix = inverse(uModelViewMatrix);
      normalMatrix = transpose(normalMatrix);

      vec4 pos = vec4(aVertexPosition,1.0);
      vec4 normal = normalMatrix*vec4(aVertexNormal,0.0);
      vec4 light =  uNormalMatrix*vec4(uLightPos,1.0);
      vec4 newPos = uProjectionMatrix*uModelViewMatrix * pos;
      vColor = vec4(aVertexColor,1.0); 

      vec3 normalVec = normalize(vec3(normal));
      vec3 lightVec = normalize(vec3(light));
      vec3 eyeVec = normalize(vec3(uEyePos));

      float lambert = dot(normalVec,lightVec);
      vec4 matDiff,matSpec;

      //Se houver textura, o material da superficie e definido pela cor dos vertices
      if (uTextureActive==0){
        matDiff = vColor;
        matSpec = vColor;
      }
      else{// se nao é um cor branca
        matDiff = vec4(1.0,1.0,1.0,1.0);
        matSpec = vec4(1.0,1.0,1.0,1.0);
      }

      vec3 Ia; //Iluminacao ambiental
      vec3 Id; //Iluminacao Difusa
      vec3 Is; //Iluminacao Especular
      float Ka = 0.4;
      float Kd = 0.5;
      float Ks = 0.5;
      float ns = 8.0;

      //Calculo da compoenente ambiental
      Ia = Ka*vec3(1.0,1.0,1.0);

      //Se o coeficiente de atenuacao difusa for positivo
      if (lambert>0.0){//multiplica o coeficiente pelo material
        vec3 refVec = reflect(lightVec,normalVec);
        float angSpec = max(0.0,dot(refVec,eyeVec));
        float specular = pow(angSpec,ns);
        Id = Kd*vec3(lambert*matDiff);
        Is = Ks*vec3(specular*matSpec);
      }
      else{//senao a iluminacao difusa e zero
        Id = vec3(1.0,0.0,0.0);
        Is = vec3(1.0,0.0,0.0);
      }
      
      vColor = vec4(Ia+Id+Is,1.0);

      gl_PointSize = 8.0;
      gl_Position = newPos;
      vTextureCoordinate = aTextureCoordinate;
      //vNormal = aVertexNormal;
    }
  </script>
  


  <!-- fragment shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;
    precision mediump int;
    in vec4 vColor;
    in vec3 vNormal;
    in vec2 vTextureCoordinate;
    out vec4 fragColor;
    uniform int uTextureActive;


    
    uniform sampler2D uSampler;

    void main(void) {
      if (uTextureActive==0){
        fragColor = vColor*texture(uSampler,vTextureCoordinate);
        //fragColor = vec4(1.0,0.0,0.0,1.0);
      }else{
        fragColor = vColor;
        fragColor = vec4(1.0,1.0,0.0,1.0);
      }
    }
  </script>


  <script type="text/javascript">
  
    class Star extends Sphere{
        constructor(radius,div_u,div_v,color,textureName){
            super(radius,div_u,div_v,color,textureName)
            this.invertNormals();
        }

        invertNormals() {
            for (let i = 0; i < this.normals.length; i++) {
              this.normals[i] = this.normals[i] * -1;
          }
        }

    }

    class WebGLStar extends Star{
        constructor (gl,program,radius,div_u,div_v,color,textureName,filled = false, interpolation = false){
        super(radius,div_u,div_v,color,textureName);
        this.gl = gl;
        this.program = program;
        this.textureName = textureName;
        this.filled = filled;
        this.interpolation = interpolation;
        }

        getWebGLModel(attribShaderVariables = null,uniformShaderVariables = null){
                
            const webGLCubeModel = new WebGLModel(this.gl,this.program,3,this.gl.TRIANGLES,
                                                this.coords,this.indicesTriangles,this.colors,this.normals,null,this.textureCoords,this.textureName);

            webGLCubeModel.set(attribShaderVariables,uniformShaderVariables);

            return webGLCubeModel;
        }
    }

    class MyWebGLMainAPP extends WebGLMainApp{
    
        constructor(){
            super();
            this.program = null;
            this.fov = 60;
            this.rotationVector = [0.0,0.0,0.0];
            this.lightPos = [0.0,0.0,0.0];
            this.translationVector = [0.0,0.0,-20.0];
            this.stack = new SimpleGLStack();
        }

        createTransformMatrices(){
        
            this.modelViewMatrix = mat4.create();
            this.projectionMatrix = mat4.create();
            this.normalMatrix = mat4.create();

            var tv = vec3.create();

            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);

            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            
            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            //Cria a matriz de projeção com angulo de abertura de 45 graus, near plane = 0.1 e far_plane = 1000
            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

        }

        createModels(){
            /*Textures obtained from 
            https://www.myfreetextures.com/
            https://publicdomaintextures.com/
            */

            this.sun = new WebGLStar(this.gl,this.program,7.0,32,32,new Color(1.0,1.0,1.0,1.0),"ornage-fur-texture.jpg");
            this.sunModel = this.sun.getWebGLModel();

            this.planet = new WebGLSphere(this.gl,this.program,3.0,32,32,new Color(0.0,1.0,0.0,1.0),"leather05 diffuse 1k.png");
            this.planetModel = this.planet.getWebGLModel();

            const controlPoints = new PointList();
            controlPoints.push(new Point3d(-4.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(-4.0,0.0,4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(4.0,0.0,4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(4.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(0.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(0.0,10.0,-4.0,new Color(1.0,0.0,0.0),8));
            const bezier = new WebGLBezier(this.gl,this.programLines,new Color(0.0,0.0,1.0),controlPoints,5,32,false,false);
            this.bezierModel = bezier.getWebGLModel();


            const controlPoints2 = new PointList();
            controlPoints2.push(new Point3d(-8.0,0.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(-8.0,0.0,8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(8.0,0.0,8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(8.0,0.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(0.0,8.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(0.0,16.0,16.0,new Color(1.0,0.0,0.0),8));
            const knots = [0,0,0,0,1,4,5,5,5,5];

            this.bspline = new WebGLBSpline(this.gl,this.programLines,new Color(1.0,1.0,0.0),controlPoints2,knots,3,32);
            this.bsplineModel = this.bspline.getWebGLModel();

            this.cyl = new WebGLCylinder(this.gl,this.programNoise,1.0,1.0,128,128,new Color(1.0,0.0,0.0,1.0),"white-fur-texture.jpg");
            this.cylModel = this.cyl.getWebGLModel();

        }

        async create(){
        
            // Carrega um program       
            //this.program = this.createProgram("vertex-shader","fragment-shader");
            this.program = await this.loadProgram("vertexShader.sh","fragmentShader.sh");
            this.programLines = await this.loadProgram("vertexShaderLines.sh","fragmentShaderLines.sh");
            this.programNoise = await this.loadProgram("vertexShaderNoise.sh","fragmentShader.sh");
            
            this.gl.useProgram(this.program);

            //Define as variáveis attribute e uniform dos shaders
            this.attribShaderVariables = {"aVertexPosition":"aVertexPos",
                                          "aVertexColor":"aVertexColor",
                                          "aVertexNormal":"aVertexNormal",
                                          "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderVariables = ["uVertexPointSize","uModelViewMatrix","uNormalMatrix","uProjectionMatrix",
                                           "uLightPos","uEyePos","uTextureActive","uSampler"];

            //Define as variáveis attribute e uniform dos shaders
            this.attribShaderLinesVariables = {"aVertexPosition":"aVertexPosition",
                                              "aVertexColor":"aVertexColor",
                                              "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderLinesVariables = ["uVertexPointSize","uModelViewMatrix","uProjectionMatrix","uTextureActive","uSampler"];
            

            //Obtem a localização das variáveis no shader
            this.setProgramAttribShaderVariablesLocation(this.program,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.program,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programNoise,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.programNoise,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programLines,this.attribShaderLinesVariables);
            this.setProgramUniformShaderVariablesLocation(this.programLines,this.uniformShaderLinesVariables);

            this.createTransformMatrices();
            
            this.createModels();

            var uniformShaderVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uNormalMatrix":["mat4",false,this.normalMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uLightPos":["3f",this.lightPos[0],this.lightPos[1],this.lightPos[2]],
                                                "uEyePos":["3f",this.translationVector[0],this.translationVector[1],this.translationVector[2]],
                                                "uTextureActive":["1i",1],
                                                "uSampler":["1i",0]};
            
            var uniformShaderLinesVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uTextureActive":["1i",0],
                                                "uSampler":["1i",0]};

            this.setProgramUniformShaderVariablesValues(this.program,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programNoise,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programLines,uniformShaderLinesVariablesValues);
        }


        drawScene(modelViewMatrix){
            var tv = vec3.create();
            
            // Sun
            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  0.0, 0.0, 0.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.sunModel.program,modelViewMatrix,"uModelViewMatrix");
                this.sunModel.draw(modelViewMatrix);

                var transformedLightPos = vec3.create();
                mat4.translate(transformedLightPos, modelViewMatrix, tv);
                var lightPosUniform = this.gl.getUniformLocation(this.program, "uLightPos");
                console.log(transformedLightPos);
                this.gl.uniform3fv(lightPosUniform, transformedLightPos);

            modelViewMatrix = this.stack.pop();
            

            // Planet
            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  -10.0, -2.0, -15.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.planetModel.program,modelViewMatrix,"uModelViewMatrix");
                this.planetModel.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();        
        }


        draw() {
           
            
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
           
            var tv = vec3.create();
            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);
        
            //this.rotationVector[1]+=1;
            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            this.updateModelViewMatrix(this.program,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programLines,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programNoise,this.modelViewMatrix,"uModelViewMatrix");  
            
            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            this.updateNormalMatrix(this.program,this.normalMatrix,"uNormalMatrix");            
            this.updateNormalMatrix(this.programLines,this.normalMatrix,"uNormalMatrix");    
            this.updateNormalMatrix(this.programNoise,this.normalMatrix,"uNormalMatrix");           


            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

            this.updateProjectionMatrix(this.program,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programLines,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programNoise,this.projectionMatrix,"uProjectionMatrix");
            
            this.drawScene(this.modelViewMatrix);

        } 

        initControls(){
        
            var obj = this;

            //var axis = ["x","y","z"];

            // A wrapper around dat.GUI interface for a simpler API
            // for the purpose of this book
            utils.configureControls({
                
                /*
                'Rendering Mode': {
                value: renderingMode,
                options: [
                    'TRIANGLES',
                    'LINES',
                    'POINTS',
                    'LINE_LOOP',
                    'LINE_STRIP',
                    'TRIANGLE_STRIP',
                    'TRIANGLE_FAN'
                ],
                onChange: v => {renderingMode = v;render();}
                },*/

                
                // reduce receives a function and the initial value (below the initial value is {})
                // result is the initial value or the return of the previous call to the function
                // Spread all values from the reduce onto the controls
                ...['Translate X', 'Translate Y', 'Translate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.translationVector[i],
                    min: -100, 
                    max: 100, 
                    step: 0.000001,
                    onChange(v, state){
                    obj.translationVector[i] = v;
                    obj.draw(); 
                    }
                };
                return result;
                }, {}),


                ...['Rotate X', 'Rotate Y', 'Rotate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.rotationVector[i],
                    min: -180, max: 180, step: 0.000001,
                    onChange(v, state) {
                    obj.rotationVector = [
                        state['Rotate X'],
                        state['Rotate Y'],
                        state['Rotate Z']
                    ];
                    obj.draw();  

                    }
                };
                return result;
                }, {}),

                
                'fov':{
                value: obj.fov,
                min : 0.0,
                max : 120,
                step: 0.001,
                onChange(v,state){
                    obj.fov = v;
                    obj.draw();
                }
            }
        })
    }



        init() {
            this.gl.clearColor(0.7, 0.7, 0.9, 1.0);
            this.gl.enable(this.gl.DEPTH_TEST);
            super.init();
        }
   
  }

  </script>
</head>

<body>

  <canvas id="webgl-canvas" width="800" height="800">
    Your browser does not support the HTML5 canvas element.
  </canvas>

  <script type="text/javascript">
      let myWebGLMainAPP = new MyWebGLMainAPP();
      window.onload = myWebGLMainAPP.init();
  </script>

</body>

</html>
