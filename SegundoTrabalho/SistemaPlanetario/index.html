
<!-- MIT License

Copyright (c) 2018 Packt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. -->

<!--Este código é um reprodução, alteração ou extensão de parte dos códigos que podem ser obtidos em
https://github.com/PacktPublishing/Real-Time-3D-Graphics-with-WebGL-2/blob/master/LICENSE  
sob a licença acima especificada.
-->
<html>
<head>
  <title>Rendering primitives</title>
  <!--<link rel="shortcut icon" type="image/png" href="../common/images/favicon.png" />-->

  <!-- libraries -->
  <link rel="stylesheet" href="../lib/normalize.css">
  <script type="text/javascript" src="../lib/dat.gui.js"></script>
  <script type="text/javascript" src="../lib/gl-matrix.js"></script>

  <!-- modules -->
  <script type="text/javascript" src="../js/utils.js"></script>
  <script type="text/javascript" src="../shapes2d.js"></script>
  <script type="text/javascript" src="../shapes3d.js"></script>
  <script type="text/javascript" src="../mystack.js"></script>

  <!-- vertex shader -->
  <script id="illumination-shader" type="x-shader/x-vertex">
    #version 300 es
    precision mediump float;
    precision mediump int;

    in vec3 aVertexPosition;
    in vec3 aVertexColor;
    in vec3 aVertexNormal;
    in vec2 aTextureCoordinate;
    

    smooth out vec4 vColor;
    smooth out vec3 vNormal;
    out vec2 vTextureCoordinate;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uNormalMatrix;
    uniform mat4 uProjectionMatrix;
    uniform int uTextureActive;
    uniform vec3 uLightPos;
    uniform vec3 uEyePos;

    void main(void) {
      
      vec4 pos = vec4(aVertexPosition,1.0);
      vec4 normal = uNormalMatrix*vec4(aVertexNormal,0.0);
      vec4 light =  uNormalMatrix*vec4(uLightPos,1.0);
      vec4 newPos = uProjectionMatrix*uModelViewMatrix * pos;
      vColor = vec4(aVertexColor,1.0); 

      vec3 normalVec = normalize(vec3(normal));
      vec3 lightVec = normalize(vec3(light));
      vec3 normalEyePos = normalize(vec3(newPos) - uEyePos);

      float lambert = dot(normalVec,lightVec);
      vec4 matDiff,matSpec;

      //Se houver textura, o material da superficie e definido pela cor dos vertices
      if (uTextureActive==0){
        matDiff = vColor;
        matSpec = vColor;
      }
      else{// se nao é um cor branca
        matDiff = vec4(1.0,1.0,1.0,1.0);
        matSpec = vec4(1.0,1.0,1.0,1.0);
      }

      vec3 Ia = vec3(1.0,1.0,1.0); //Iluminacao ambiental
      vec3 Id; //Iluminacao Difusa
      float Ka = 0.3;
      float Kd = 0.4;
      float Ks = 0.8;
      float ns = 20.0;
      float Is = 0.0;

      //Se o coeficiente de atenuacao difusa for positivo
      if (lambert>0.0){//multiplica o coeficiente pelo material
        Id = vec3(lambert*matDiff);
        // Comp Especular        
        vec3 reflectVec = reflect(lightVec, normalVec);
        float specAngle = max(0.0, dot(-normalVec, reflectVec));
        Is = pow(specAngle, ns);
      }
      else{//senao a iluminacao difusa e zero
        Id = vec3(0.0,0.0,0.0); 
        Is = 0.0;       
      }      

      vColor = vec4(Id*Kd + Ia*Ka + Is*Ks*vec3(matSpec),1.0);

      gl_PointSize = 8.0;
      gl_Position = newPos;
      vTextureCoordinate = aTextureCoordinate;
      //vNormal = aVertexNormal;
    }
  </script>

  <!-- fragment shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;
    precision mediump int;
    in vec4 vColor;
    //in vec3 vNormal;
    in vec2 vTextureCoordinate;
    out vec4 fragColor;
    uniform int uTextureActive;


    
    uniform sampler2D uSampler;

    void main(void) {
      if (uTextureActive==1){
        fragColor = vColor*texture(uSampler,vTextureCoordinate);
      }else{
        fragColor = vColor;
      }
    }
  </script>

  <script type="text/javascript">
    'use strict';

    let gl,
        program,
        //Quaternion angle
        angleQuat = 0.0,
        //Define o vetor de translação em z
        translationVector = [0.0,0.0,-50.0],
        //Define um vetor com ângulos de rotação em cada um dos eixos (x,y,z)
        rotationVector = [0.0,0.0,0.0],
        lightPos = [0.0,0.0,1.0],
        //Criar a matriz de camera e modelagem 4x4
        modelViewMatrix,
        //Criar a matriz de transformacao da normal 4x4
        normalMatrix,
        //Cria a matriz de projeção 4x4
        projectionMatrix,      
        // Global variable that captures the current rendering mode type
        renderingMode = 'TRIANGLES',
        myMatrixStack,
        sun,
        grass,
        eyeBall,
        furBall,
        furBall2,
        furCyl,
        fov = 60;

    
    class Star extends MySphere{
        constructor(program,gl,radius,div_u,div_v,color,textureName){
            super(program,gl,radius,div_u,div_v,color,textureName);
        }

        invertNormals() {
            console.log(this.normals)
            for (let i = 0; i < this.normals.length; i++) {
              this.normals[i] = this.normals[i] * -1;
            }
            console.log(this.normals);
        }
        
        draw(renderingMode){
            this.invertNormals();
            super.draw(renderingMode);
        }
    }

    //Função que constroi um shader (Vertex ou Fragment shader)
    function getShader(id) {
      const script = document.getElementById(id);
      const shaderString = script.text.trim();

      let shader;
      if (script.type === 'x-shader/x-vertex') {
        shader = gl.createShader(gl.VERTEX_SHADER);
      }
      else if (script.type === 'x-shader/x-fragment') {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      }
      else {
        return null;
      }

      gl.shaderSource(shader, shaderString);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function initProgram() {
      const illuminationShader = getShader('illumination-shader');
      const fragmentShader = getShader('fragment-shader');

      program = gl.createProgram();
      gl.attachShader(program, illuminationShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Could not initialize shaders');
      }

      gl.useProgram(program);

      program.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
      program.aVertexColor = gl.getAttribLocation(program,'aVertexColor');
      program.aTextureCoordinate = gl.getAttribLocation(program, 'aTextureCoordinate');
      program.aVertexNormal = gl.getAttribLocation(program, 'aVertexNormal');
     
      program.uTextureActive = gl.getUniformLocation(program, 'uTextureActive');
      program.uSampler = gl.getUniformLocation(program, 'uSampler');

      program.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
      // Buscar o handle da variavel que armazena no vertex shader a matriz normal 
      program.uNormalMatrix = gl.getUniformLocation(program, 'uNormalMatrix');
      program.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
      // Buscar o handle da variavel que armazena no vertex shader a posicao da luz
      program.uLightPos = gl.getUniformLocation(program, 'uLightPos');

    }

    function drawSolarSystem(){
        var s = vec3.create();
        var t = vec3.create();
        
        //Universe
        myMatrixStack.push(mat4.clone(modelViewMatrix));            
            vec3.set(t, 0.0, 0.0, 0.0);
            mat4.translate(modelViewMatrix,modelViewMatrix,t);

            // Sun 
            myMatrixStack.push(mat4.clone(modelViewMatrix));

                vec3.set(t, 0.0, 0.0, 0.0);
                mat4.translate(modelViewMatrix,modelViewMatrix,t);

                    // Sun Light
                    myMatrixStack.push(mat4.clone(modelViewMatrix));
                        vec3.set(t, 0.0, 0.0, 1.0);
                        mat4.translate(modelViewMatrix,modelViewMatrix,t);
                        gl.uniform3fv(program.uLightPos, t);
                    
                    modelViewMatrix = myMatrixStack.pop();

                // Applying to object
                gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);

                sun.draw(renderingMode);

            modelViewMatrix = myMatrixStack.pop();

            // Drawing Planet

        modelViewMatrix = myMatrixStack.pop();
    }

    function draw() {
      
      gl.clearColor(0.0,0.5,1.0,1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      drawSolarSystem();
    }

    function render() {

        /*
        var b = Math.cos(angleQuat/2.0);
        var a = Math.sin(angleQuat/2.0);
        var e = [1,1,1];
        var norm = 1; //Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);
        var q = quat.fromValues(a*e[0]/norm, a*e[1]/norm, a*e[2]/norm, b);
        */

        //var q = quat.create();
        //q = quat.fromEuler(q,45.0,0,0);

              
        var axis = vec3.fromValues(1.0/Math.sqrt(3),1.0/Math.sqrt(3),1.0/Math.sqrt(3));
        var q = quat.create();
        q = quat.setAxisAngle(q,axis,angleQuat);

        var mat = mat4.create();
        mat = mat4.fromQuat(mat,q);


        //Atualiza as matrizes de transformação de câmera e projeção
        var tv = vec3.create();
        vec3.set(tv, translationVector[0], translationVector[1], translationVector[2]);
        
        mat4.identity(modelViewMatrix);
        mat4.translate(modelViewMatrix,modelViewMatrix,tv);
        mat4.rotateX(modelViewMatrix,modelViewMatrix,rotationVector[0]* Math.PI / 180);
        mat4.rotateY(modelViewMatrix,modelViewMatrix,rotationVector[1]* Math.PI / 180);
        mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotationVector[2]* Math.PI / 180);
        mat4.mul(modelViewMatrix,modelViewMatrix,mat);
  
        mat4.identity(normalMatrix);
        mat4.invert(normalMatrix,modelViewMatrix);
        mat4.transpose(normalMatrix,normalMatrix);

        //Envia as matrizes de camera e projeção para o shader
        gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);
        //Envia a matriz normal e a posicao da luz para o vertex shader
        gl.uniformMatrix4fv(program.uNormalMatrix, false, normalMatrix);
        //gl.uniform3fv(program.uLightPos, lightPos);
        gl.uniform3fv(program.uEyePos, translationVector);

        draw();
    }

    function init() {
      const canvas = utils.getCanvas('webgl-canvas');
      //canvas.width = window.innerWidth;
      //canvas.height = window.innerHeight;

      gl = utils.getGLContext(canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.enable(gl.DEPTH_TEST);

      initProgram();
      gl.uniform1i(program.uSampler, 0);

      myMatrixStack = new MyStack();
      /*Textures obtained from 
      https://www.myfreetextures.com/
      https://publicdomaintextures.com/
      */
      sun = new Star(program, gl, 1.0, 32, 32, new Color(0.0, 0.0, 1.0));
      
      var tv = vec3.create();
      vec3.set(tv, translationVector[0], translationVector[1], translationVector[2]);
      modelViewMatrix = mat4.create();
      mat4.fromTranslation(modelViewMatrix,tv);

      //Define a matriz normal
      normalMatrix = mat4.create();
      mat4.invert(normalMatrix,modelViewMatrix);
      mat4.transpose(normalMatrix,normalMatrix);

      projectionMatrix = mat4.create();
      //Cria a matriz de projeção com angulo de abertura de 45 graus, near plane = 0.1 e far_plane = 1000
      mat4.identity(projectionMatrix);  
      mat4.perspective(projectionMatrix, fov*(Math.PI/180), gl.canvas.width / gl.canvas.height, 0.1, 1000);

      render();

      initControls();
    }

    window.onload = init;

    function initControls() {
      
      var axis = ["x","y","z"];

      // A wrapper around dat.GUI interface for a simpler API
      // for the purpose of this book
      utils.configureControls({
        'Rendering Mode': {
          value: renderingMode,
          options: [
            'TRIANGLES',
            'LINES',
            'POINTS'
            /*,
            'LINE_LOOP',
            'LINE_STRIP',
            'TRIANGLE_STRIP',
            'TRIANGLE_FAN'*/
          ],
          onChange: v => {renderingMode = v;render();}
        },

        /*       
        'RotationAngle': {
          value: rotationAngle,
          min : 0.0,
          max : 2*Math.PI,
          step: 0.001,
          onChange(v,state){
              rotationAngle = v;
              var tv = vec3.create();
              vec3.set(tv, translationVector[0], translationVector[1], translationVector[2]);
              mat4.identity(modelViewMatrix);
              mat4.translate(modelViewMatrix,modelViewMatrix,tv);
              mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotationAngle);
              gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);

              gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);

              render();
          }
        }, */

        /*
        'TranslateX':{
          value: translationVector[0],
          min:-1.0, 
          max: 1.0,
          step:0.01,
          onChange(v, state){
            mat4.identity(modelViewMatrix);
            mat4.translate(modelViewMatrix,modelViewMatrix,[v,translationVector[0],0,0]);
            gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
            render(); 
          }
        } */

        // reduce receives a function and the initial value (below the initial value is {})
        // result is the initial value or the return of the previous call to the function
        // Spread all values from the reduce onto the controls
        ...['Translate X', 'Translate Y', 'TranslateZ'].reduce((result, name, i) => {
          result[name] = {
            value: translationVector[i],
            min: -100, 
            max: 100, 
            step: 0.000001,
            onChange(v, state){
              translationVector[i] = v;
              render(); 
            }
          };
          return result;
        }, {}),


        ...['Rotate X', 'Rotate Y', 'Rotate Z'].reduce((result, name, i) => {
          result[name] = {
            value: rotationVector[i],
            min: -180, max: 180, step: 0.000001,
            onChange(v, state) {
              rotationVector = [
                state['Rotate X'],
                state['Rotate Y'],
                state['Rotate Z']
              ];
              render();  

            }
          };
          return result;
        }, {}),

        'angleQuat':{
          value: angleQuat,
          min : 0.0,
          max : 2*Math.PI,
          step: 0.001,
          onChange(v,state){
              angleQuat = v;
              render();
          }
        },
        'fov':{
          value: fov,
          min : 0.0,
          max : 120,
          step: 0.001,
          onChange(v,state){
              fov = v;
              mat4.perspective(projectionMatrix, fov*(Math.PI/180), gl.canvas.width / gl.canvas.height, 0.1, 500);
              render();
          }
        }

   
      })
    }
  </script>
</head>

<body>

  <canvas id="webgl-canvas" width="1024" height="512">
    Your browser does not support the HTML5 canvas element.
  </canvas>

</body>
</html>
